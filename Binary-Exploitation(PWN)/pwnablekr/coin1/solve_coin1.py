from pwn import *
import time

# Helper function to generate space-separated string of indices
def get_indices(start, end):
    return ' '.join(str(i) for i in range(start, end + 1))

# The actual solver logic to be run on the server
# We wrap this in a big string to upload it
solver_code = r"""
import socket
import sys
import time
import re

def solve():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('127.0.0.1', 9007))
    
    # Receive banner
    print(s.recv(2048).decode())
    
    for i in range(100):
        # Read N and C
        # Output format: "N=4 C=2"
        data = b""
        while b"N=" not in data:
            chunk = s.recv(1024)
            if not chunk: break
            data += chunk
            
        decoded = data.decode()
        print(f"Game {i+1}: {decoded.strip()}")
        
        # Parse N and C
        match = re.search(r'N=(\d+) C=(\d+)', decoded)
        if not match:
            print("Error parsing N/C")
            break
            
        N = int(match.group(1))
        C = int(match.group(2))
        
        low = 0
        high = N - 1
        
        # Perform C queries
        for _ in range(C):
            # If we already found the coin, just waste chances or send known index
            # But the game expects loop C times? Let's verify standard binary search.
            # Actually range is [low, high].
            # We weigh [low, mid].
            
            mid = (low + high) // 2
            
            # Construct query: list of indices from low to mid
            # Indices are usually 0-based based on example? 
            # Example: 0 1 -> weigh first and second.
            
            count = mid - low + 1
            query = " ".join(str(x) for x in range(low, mid + 1))
            s.send((query + "\n").encode())
            
            # Read result
            res = s.recv(1024).decode().strip()
            
            # Handle possible partial reads or extra text
            while not res.isdigit() and "Correct" not in res:
                # might act weird if buffering, but usually simple line response
                 # If we see "Correct", it means previous round done? No, server responds number.
                if "Correct" in res:
                     # This shouldn't happen mid-loop unless we finished early?
                     pass
                extra = s.recv(1024).decode().strip()
                res += extra

            # If weight is multiple of 10, these coins are real.
            # Real weight = count * 10
            
            if "Correct" in res:
                # We accidentally triggered correct? Maybe sent single index?
                break
            
            try:
                weight = int(res)
            except:
                # Maybe format is "9\nCorrect!" if last guess?
                parts = res.split()
                if parts[0].isdigit():
                    weight = int(parts[0])
                else:
                    print(f"Debug: {res}")
                    break

            if weight == count * 10:
                # Fake is in the other half
                low = mid + 1
            else:
                # Fake is in this half
                high = mid
        
        # Send the final answer?
        # The instructions say: "2~3 repeats C time, then you give the answer"
        # Wait, the example:
        # Client: 3
        # Server: 10
        # Client: 2
        # Server: Correct!
        # It implies you just send the index at the end? 
        # OR if you send a single index and it's 9, does it count as answer?
        # Example shows: "counterfeit coin is third!" -> Client sends '2'.
        # Actually in Binary Search, when low == high, we found it.
        # Do we need to explicitly say it?
        # The protocol seems to simply define finding it as sending a verification query?
        # Re-reading example:
        # [Client] 2
        # [Server] Correct!
        # This 2 looks like a query. Since it's a single coin, server checks it?
        # If single coin query returns 9, server knows we found it?
        # Or maybe the loop continues until we run out of C or we find it.
        
        # If we narrow down to 1 coin, do we send it?
        # With binary search, we should find it within C tries easily.
        # When low == high, we send that index.
        # If we still have C left, we might need to send it.
        
        if low != high:
             # Should not happen if C is sufficient (log2(N))
             pass
        
        s.send(f"{low}\n".encode())
        print(s.recv(1024).decode()) # Expect Correct!

    # Final Flag
    print(s.recv(2048).decode())
    s.close()

if __name__ == "__main__":
    solve()
"""

# Upload and execute
user = 'coin1'
host = 'pwnable.kr'
port = 2222
password = 'guest'

s = ssh(user=user, host=host, port=port, password=password)

# Create workspace
workspace = "/tmp/solve_coin1_rommel"
s.process(['mkdir', '-p', workspace]).recvall()

# Upload
log.info("Uploading solver script...")
local_path = "/tmp/coin_solver.py"
with open(local_path, "w") as f:
    f.write(solver_code)
s.put(local_path, remote=f"{workspace}/solver.py")

# Run
log.info("Running solver on server...")
p = s.process(['python3', f"{workspace}/solver.py"])
p.interactive()
